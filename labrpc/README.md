## Usage

The labrpc library provides a user with a `Client` type client, which offers two primary services:

*   `add_service`: This function allows users to add a service to the server. It requires two arguments:
    *   The name of the service, typically the struct name.
    *   A service instance wrapped in a `Box`, which must implement the `Service` trait. This trait is usually implemented using the `labrpc_macros::rpc` proc_macro.

After adding a service, other peers can make requests to it.

*   `peers`: This function returns an iterator of peers in the network. The iterator yields a `Option<ClientEnd>` type on each call.

Note that `peers` only provides a snapshot of network peers and may return errors like `TIMEOUT` or `PEER_NOT_FOUND`.

### `ClientEnd`

A `ClientEnd` is a handle provided by a node, enabling peers to send RPC requests to it. The `ClientEnd` offers two primary APIs:

*   `id`: This function returns the ID of the node that this RPC request will be sent to.
*   `call`: This function sends an RPC request to the node. It takes two generic arguments: the type of the RPC argument and the type of the RPC reply, respectively.

For example, if we have a `Hello` service with a `hello` method:
```rust
struct Hello;

#[rpc(Service, CallResult, err)]
impl Hello {
    pub fn hello(&self, name: String) -> String {
        format!("Hello, {name}")
    }
}
```
We can request the `hello` method using a `ClientEnd` as follows:
```rust
let peer: ClientEnd;
// The return value is of type `Result<String, labrpc::Error>`
let ret = peer.call::<_, String>("Hello.hello", "Lunar".to_string()).await;
```
This process is straightforward.

### Network

To simplify simulations, we assume the network has a fixed number of members. When creating a `Network` instance, you need to specify the size of the network using the `size` argument.

In cases where a raft node crashes, we ensure it does not affect the current network environment by preventing it from sending outdated messages. We achieve this by assigning each `Client` a unique pass key, which must be included in any message sent between nodes.

Here's an example of a message structure:
```rust
struct Msg {
    pub key: Key,
    pub from: Idx,
    pub to: Idx,
    pub req: RpcReq,
    pub reply_tx: OneTx<CallResult>
}
```
When the network receives a message, it checks whether the pass key in the message matches the current pass key of the sending node. If they match, the message is considered valid, and the request is dispatched to the intended server.

### Error Forwarding

During system execution, various errors can occur. However, only some of them are propagated; others cause the program to crash.

For instance, errors generated by third-party libraries are immediately unwrapped from their `Result` types.

There are two primary kinds of errors:

*   Network errors: These include possible network errors in the simulated environment, such as `Timeout`, `PeerNotFound`, etc.
*   Service errors: These are RPC service-related errors thrown by servers, like `ClassNotFound`, `MethodNotFound`, etc.
